<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Mach-O 可执行文件格式]]></title>
      <url>http://blog.zdzhong.com/2017/03/06/Mach-O-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="Mach-O-可执行文件格式"><a href="#Mach-O-可执行文件格式" class="headerlink" title="Mach-O 可执行文件格式"></a>Mach-O 可执行文件格式</h1><p>在OS X和iOS中可执行文件是Mach-O格式的。Mach-O 被设计成替换成 BSD 中 a.out 的可扩展格式，动态链接的特性也随着 OS X 的发展得到支持。本文介绍 Mach-O 文件格式。<br><a id="more"></a></p>
<h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><ul>
<li>Header，每个 Mach-O 文件的开始都是头部，包含了基本文件类型信息，目标架构和说明剩余文件的标志。</li>
<li>Load Command，头部之后就是一系列长度不定的 load commands，表明了文件的布局和特征，load commands 可以表明：<ul>
<li>文件在虚拟内存中的初始化结构</li>
<li>符号表的位置</li>
<li>程序主线程的初始化执行状态</li>
<li>包含被引用符号的共享库的名字</li>
</ul>
</li>
<li>Segment,在 load commands 之后所有的 Mach-O 文件，都会包含一个或多个 segment 的数据。每个段（segment）包含一个或多个 section。每个 区（section）包含代码或者某些特定类型的数据。每个段定义了一块虚拟内存的区域用来让动态链接器把进程的空间加载到对应的地址。段和区的布局和数量是由 load commands 和文件类型决定的。</li>
<li>在用户层链接完成的 Mach-O 文件中，最后一个segment 是 link edit。包含了link edit信息表，包括符号表，字符表等等，用来让动态加载器去链接可执行文件或者 Mach-O bundle依赖的库。<img src="/images/Mach-O_file_format/Mach-O_file_format_basic_structure.png" alt="Mach-O_file_format_basic_structure"></li>
</ul>
<h2 id="Header-结构和-Load-Commands"><a href="#Header-结构和-Load-Commands" class="headerlink" title="Header 结构和 Load Commands"></a>Header 结构和 Load Commands</h2><p>一个 Mach-O 文件包含了一种架构的代码和数据，头部结构说明了目标架构由内核来保证，PowerPC 架构的不能在 Intel 架构的机器上运行。</p>
<p>可以用工具将多种架构的 Mach-O 文件合并在一个二进制文件中。（包含多种架构的文件不是 Mach-O 文件，是多个 Mach-O 文件的 archive）</p>
<p>segments 和 sections 通常用名字访问，Segment 惯例是两个下划线加上大写的名字（<strong>TEXT），sections的命名是两个下划线加上小写的名字（</strong>text），命名惯例是一个标准但是没有工具保证。</p>
<p><code>otool -h Mach-O_file</code> 可以打印 header</p>
<p>例如：</p>
<table>
<thead>
<tr>
<th>magic</th>
<th>cputype</th>
<th>cpusubtype</th>
<th>caps</th>
<th>filetype</th>
<th>ncmds</th>
<th>sizeofcmds</th>
<th>flags</th>
</tr>
</thead>
<tbody>
<tr>
<td>MH_MAGIC_64</td>
<td>ARM64</td>
<td>ALL</td>
<td>0x00</td>
<td>EXECUTE</td>
<td>69</td>
<td>7232</td>
<td>0x00218085</td>
</tr>
</tbody>
</table>
<p><code>otool -v -l Mach-O_file</code> 可以打印 Load Commands</p>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Load command 0</div><div class="line">      cmd LC_SEGMENT_64</div><div class="line">  cmdsize 72</div><div class="line">  segname __PAGEZERO</div><div class="line">   vmaddr 0x0000000000000000</div><div class="line">   vmsize 0x0000000100000000</div><div class="line">  fileoff 0</div><div class="line"> filesize 0</div><div class="line">  maxprot ---</div><div class="line">  initprot ---</div><div class="line">   nsects 0</div><div class="line">    flags (none)</div><div class="line">Load command 1</div><div class="line">      cmd LC_SEGMENT_64</div><div class="line">  cmdsize 952</div><div class="line">  segname __TEXT</div><div class="line">   vmaddr 0x0000000100000000</div><div class="line">   vmsize 0x000000000109c000</div><div class="line">  fileoff 0</div><div class="line"> filesize 17416192</div><div class="line">  maxprot r-x</div><div class="line">  initprot r-x</div><div class="line">   nsects 11</div><div class="line">    flags (none)</div><div class="line">Load command 64</div><div class="line">      cmd LC_LOAD_DYLIB</div><div class="line">  cmdsize 56</div><div class="line">     name @rpath/libswiftUIKit.dylib (offset 24)</div><div class="line">     time stamp 2 Thu Jan  1 08:00:02 1970</div><div class="line">  current version 800.10.13</div><div class="line">compatibility version 1.0.0</div></pre></td></tr></table></figure>
<h2 id="Segments"><a href="#Segments" class="headerlink" title="Segments"></a>Segments</h2><p>Segments 在 Mach-O 文件中定义一些数据、地址和内存保护属性，在动态连接器加载程序的时候这些数据都会被映射到虚拟内存中，一个 segment 包含0或多个 section。</p>
<p>Segments 可以比在磁盘中的实际大小声明一块更大的内存，比如 <strong>PAGEZERO 段在链接器为PowerPC生成可执行文件时在磁盘的大小为0，但是在虚拟内存中会有一个page的大小。应该 </strong>PAGEZERO 没有数据，所以没有必要在可执行文件中红占用空间。</p>
<p>为了压缩空间在中间目标文件中只有一个segment，这个 segment 没有名字，包含的所有 section 在最终的目标文件中会被分成不同的 segment， 根据 section 中的 segname 分成不同的 segment。</p>
<p>为了最优的性能，segment 应该和虚拟内存的边界对齐（在PowerPC和X86处理器上是4096bytes），计算 Segment 的大小是把所有包含的所有 section 大小加上，然后对齐到虚拟内存页大小（4096bytes），所以 segment 的大小是4kb的倍数。</p>
<p>OS X 可执行文件一般包含的的 segment 有：</p>
<ul>
<li>__PAGEZERO，可执行文件的第一个 segment，空指针陷阱段，用于捕捉对空指针的引用立即crash，虚拟内存的第一页。</li>
<li><strong>TEXT，包含可执行代码和只读的数据，为了能够让内核直接把它从可执行文件映射到共享内存中，静态链接器把这个段的虚拟内存权限设置为不可写。当这个 segment 加载到内存中之后可以在多个进程中共享使用（主要是framework，bundle 和共享库，也可以在一个可执行文件的多进程拷贝执行中使用），由于这个 segment 是不可写的，所以不需要写回磁盘。当内核需要释放物理内存的时候，只需要简单释放一个或多个 </strong>TEXT 页，在需要时再从磁盘中读取。</li>
<li><strong>DATA，包含可写数据，静态链接器将这个段的虚拟内存权限设置成可读可写，因为可写的原因所以framework和共享库的</strong>DATA段会在每个链接了这个库的进程都拷贝一份。当像__DATA段一样可写可读的段的内存页，内核会把这些内存页标记成copy-on-write。当有进场需要往页里面写数据时，会先拷贝一份作为这个进程私有的再修改。</li>
<li>__OBJC，包含了 Objective-C 运行时支持库需要的数据。</li>
<li>__LINKEDIT，包含动态链接器所需要的原始数据，比如符号，字符串，重定位表条目等。</li>
</ul>
<h2 id="Sections"><a href="#Sections" class="headerlink" title="Sections"></a>Sections</h2><p><code>otool -s &lt;segname&gt; &lt;sectname&gt;</code> 可以打印 Mach-O 文件中的 section 内容</p>
<p>__TEXT 段的 sections</p>
<table>
<thead>
<tr>
<th>Segment and section name</th>
<th>Contents</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TEXT, </strong>text</td>
<td>可执行的机器码</td>
</tr>
<tr>
<td><strong>TEXT, </strong>cstring</td>
<td>c字符串常量 </td>
</tr>
<tr>
<td><strong>TEXT, </strong>picssymbol_-stub</td>
<td>Position-independent indirect symbol stubs</td>
</tr>
<tr>
<td><strong>TEXT, </strong>symbol_stub</td>
<td>Indirect symbol stubs.</td>
</tr>
<tr>
<td><strong>TEXT, </strong>const</td>
<td>初始化的 const 变量</td>
</tr>
<tr>
<td><strong>TEXT, </strong>literal4</td>
<td>4byte的字面量</td>
</tr>
<tr>
<td><strong>TEXT, </strong>literal8</td>
<td>8byte的字面量</td>
</tr>
</tbody>
</table>
<p>__DATA 段的 sections</p>
<table>
<thead>
<tr>
<th>Segment and section name</th>
<th>Contents</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DATA, </strong>data</td>
<td>初始化的可变变量</td>
</tr>
<tr>
<td><strong>DATA, </strong>la_symbol_ptr</td>
<td>lazy 符号指针</td>
</tr>
<tr>
<td><strong>DATA, </strong>nl_symbol_ptr</td>
<td>non-lazy 符号指针</td>
</tr>
<tr>
<td><strong>DATA, </strong>dyld</td>
<td>动态链接器使用的占位 section </td>
</tr>
<tr>
<td><strong>DATA, </strong>const</td>
<td>初始化的重定位 constant 变量</td>
</tr>
<tr>
<td><strong>DATA, </strong>mod_init_func</td>
<td>模块初始化函数，C++编译器会把静态构造函数放在这</td>
</tr>
<tr>
<td><strong>DATA, </strong>mod_term_func</td>
<td>模块终止函数</td>
</tr>
<tr>
<td><strong>DATA, </strong>bss</td>
<td>未初始化的静态变量</td>
</tr>
<tr>
<td><strong>DATA, </strong>common</td>
<td>未初始化的全局符号定义</td>
</tr>
</tbody>
</table>
]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[Carthage 简介]]></title>
      <url>http://blog.zdzhong.com/2016/08/19/Carthage-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>Carthage 是一个年轻的 iOS 包管理工具，为什么在有了 CocoaPods 之后，还会出现 Carthage, Carthage 官方的理由如下：</p>
<ul>
<li>CocoaPods 默认自动创建 workspace 来管理 application 和所有依赖， Carthage 使用 xcodebuild 编译二进制 framework, 把集成的权力交给使用者， CocoaPods 的目标是容易使用， Carthage 的目标是灵活性和非侵入性。</li>
<li>CocoaPods 的说明文档中提到，为了提高第三方开源框架的集成能力以及容易扩散，创建的集中的生态系统。Carthage 的目标只是一个分散的依赖管理工具，没有维护一个所有项目的列表。（这样能避免很多集中依赖节点出错导致的问题，可能会造成开源库不容易被发现，建议使用 GitHub 的 Trending）</li>
</ul>
<a id="more"></a>
<h2 id="Carthage-VS-CocoaPods"><a href="#Carthage-VS-CocoaPods" class="headerlink" title="Carthage VS CocoaPods"></a>Carthage VS CocoaPods</h2><p>CocoaPods 的优点：</p>
<ul>
<li>使用方便，除了写 Podfile 之外基本都是命令行完成</li>
<li>支持静态库，也支持 iOS 8 以上的 framework</li>
<li>软件包比较多，主流支持</li>
</ul>
<p>缺点：</p>
<ul>
<li>每个默认更新都要更新 podsepc 仓库，很耗时</li>
<li>创建支持 CocoaPods 的相对繁琐， podsepc 写起来比较麻烦</li>
<li>每次 clean 之后编译，都要重新编译所有第三方库</li>
</ul>
<p>Carthage 的优点：</p>
<ul>
<li>将 framework 集成到项目中，不需要重复编译</li>
<li>无缝兼容 CocoaPods</li>
<li>没有中心仓库，更新很快</li>
<li>结构标准的项目天然支持 Carthage</li>
</ul>
<p>缺点：</p>
<ul>
<li>支持的库相对少一些</li>
<li>只支持 framework ，iOS 8 以上</li>
<li>无法定位源码，直接断点调试</li>
</ul>
<h2 id="Carthage-使用介绍"><a href="#Carthage-使用介绍" class="headerlink" title="Carthage 使用介绍"></a>Carthage 使用介绍</h2><p>安装 carthage 到系统，请下载并运行最新的 <a href="https://github.com/Carthage/Carthage/releases" target="_blank" rel="external">Release</a> Carthage.pkg 文件。另一种选择是使用 Homebrew 并安装 carthage 工具到系统并运行 <code>brew update</code> 和 <code>brew install carthage</code>。<br>如果想运行最新的开发版本（很有可能不稳定或不兼容），只需要简单的 clone 仓库的 master 分支，并运行 make install。</p>
<h3 id="使用-Carthage-发布-Framework"><a href="#使用-Carthage-发布-Framework" class="headerlink" title="使用 Carthage 发布 Framework"></a>使用 Carthage 发布 Framework</h3><p>Carthage 官方只支持<strong>dynamic frameworks.</strong> Dynamic frameworks 在OSX上支持任何版本，iOS上只支持 iOS8 及以上版本。</p>
<p>由于 Carthage 没有中心化的 package list，也没有项目说明格式，大部分 frameworks 应该自动构建。通过将编译 scheme 共享，让 Carthage 通过 xcodebuild 编译。通过运行 <code>carthage build --no-skip-current</code> 后检查 Build 文件夹来检测是否构建成功。</p>
<h3 id="使用-Carthage-集成-Framework"><a href="#使用-Carthage-集成-Framework" class="headerlink" title="使用 Carthage 集成 Framework"></a>使用 Carthage 集成 Framework</h3><h4 id="OSX-项目"><a href="#OSX-项目" class="headerlink" title="OSX 项目"></a>OSX 项目</h4><ol>
<li>创建一个 Cartfile ，在这个文件中列出你想使用的 frameworks</li>
<li>运行 carthage update ，获取依赖到 Carthage/Checkouts 文件夹，逐个构建</li>
<li>在工程的 target－&gt; General 选项下，拖拽 Carthage/Build 文件夹内想要添加的 framework 到 “Embedded Binaries” 选项下。</li>
</ol>
<h4 id="iOS-tvOS-watchOS-项目"><a href="#iOS-tvOS-watchOS-项目" class="headerlink" title="iOS, tvOS, watchOS 项目"></a>iOS, tvOS, watchOS 项目</h4><ol>
<li>创建一个 Cartfile ，在这个文件中列出你想使用的 frameworks</li>
<li>运行 carthage update ，获取依赖到 Carthage/Checkouts 文件夹，逐个构建</li>
<li>在工程的 target－&gt; General 选项下，拖拽 Carthage/Build 文件夹内想要添加的 framework 到 “Linked Frameworks and Libraries” 选项下。</li>
<li><p>在工程的 target－&gt; Build Phases 选项下，点击 “+” 按钮，选择 “New Run Script Phase” ，填入如下内容：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/bin/carthage copy-frameworks</div></pre></td></tr></table></figure>
<p> 并在 “Input Files” 选项里添加 framework 路径</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(SRCROOT)/Carthage/Build/iOS/LlamaKit.framework</div><div class="line">$(SRCROOT)/Carthage/Build/iOS/ReactiveCocoa.framework</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="拷贝-debug-symbols-来调试和报告-crash"><a href="#拷贝-debug-symbols-来调试和报告-crash" class="headerlink" title="拷贝 debug symbols 来调试和报告 crash"></a>拷贝 debug symbols 来调试和报告 crash</h4><p>在工程的 target－&gt; Build Phases 选项下，点击 “+” 按钮，选择 “New Copy Files Phase”.<br>点击 “Destination” 下拉菜单，选择 “Products Directory”.<br>针对每个使用的 framework，拖拽它们的 dSYM 文件。<br>当调试信息被拷贝到 built products 目录，Xcode 在断点处将符号化调用堆栈。也可以使其深入到第三方代码中去。</p>
<p>当提交到 AppStore 或者 TestFlight，Xcode 也会拷贝这些文件到应用的 .xcarchive bundle 的 dSYMs 子目录。</p>
<h4 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h4><p>在这个过程中，Carthage 会创建一些 Artifacts，最重要的是 Cartfile.resolved 文件，该文件列出了每个 framework 构建的各个版本。确保提交你的Cartfile.resolved, 因为任何人都需要那个文件来构建相同的 framework 版本。</p>
<p>在你完成了上述步骤并 push 了你的改变，其他用户只需要 fetch 这个仓库，运行 carthage boostrap来开始你添加的 framework。</p>
<h4 id="升级-frameworks"><a href="#升级-frameworks" class="headerlink" title="升级 frameworks"></a>升级 frameworks</h4><p>如果修改 Cartfile，或者将每个 framework 升级到最新的版本，只需要再次运行 carthage update。</p>
<h4 id="使用-submodules-做依赖"><a href="#使用-submodules-做依赖" class="headerlink" title="使用 submodules 做依赖"></a>使用 submodules 做依赖</h4><p>默认情况下，Carthage 将直接 checkout 依赖源文件到项目文件夹中，提交或者忽略全自己掌控。如果希望依赖用 Git submodules 代替（或许这样你就可以在他们内部commit，push），可以通过运行 carthage update 或者 carthage checkout –use-submodules</p>
<p>运行之后，Carthage 会在仓库中写入 .gitmodules 和 .git/config 文件，并自动更新当依赖的版本发生变化的时候。</p>
<h4 id="自动重新构建依赖"><a href="#自动重新构建依赖" class="headerlink" title="自动重新构建依赖"></a>自动重新构建依赖</h4><p>在开发过程中，如果想修改依赖项目中的代码，并在编译父项目的时候自动重新编译，可以添加一个 Run Script 来唤醒 Carthage，像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/bin/carthage build --platform &quot;$PLATFORM_NAME&quot; &quot;$SRCROOT&quot;</div></pre></td></tr></table></figure>
<p>注意：在这样做之前首先需要 使用 submodules，因为 plain checkouts 不能被直接修改</p>
]]></content>
      
        <categories>
            
            <category> Carthage </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[CocoaPods 使用介绍]]></title>
      <url>http://blog.zdzhong.com/2016/07/20/Cocoapods/</url>
      <content type="html"><![CDATA[<p>CocoaPods 是 iOS 开发中常用的包管理工具，本文总结了 CocoaPods 的使用步骤，以及搭建一个私有 CocoaPods repo 的过程。</p>
<a id="more"></a>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>  因为被墙，需要对ruby源做一个替换操作，移除默认源添加淘宝的ruby源，否则的话安装很可能会失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">gem sources -r https://rubygems.org/</div><div class="line">gem sources -a https://ruby.taobao.org/</div><div class="line"></div><div class="line">#确认一下:</div><div class="line">gem sources -l</div><div class="line"></div><div class="line">#校验成功后执行安装操作：</div><div class="line">sudo gem install cocoapods（默认最新版本）</div><div class="line">sudo gem install cocoapods -v 0.35 (安装指定版本的cocoaPods)</div><div class="line"></div><div class="line">#安装完成后 通过</div><div class="line">pod --version 校验安装OK并查看安装的版本号</div></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>常见操作是 使用第三方开源的代码：<br>想安装AFNetworking的最新版本，那么执行下搜索：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod search AFNetworking  (搜索AFNetworking的库的版本)</div></pre></td></tr></table></figure>
<p>如果是第一次执行，会首先把Cocoapods master repo clone 下来,也可以手动执行 pod setup.查看的方式是 cd ~/.cocoapods/repos）</p>
<p>使用文本编辑器创建一个Podfile文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi Podfile</div></pre></td></tr></table></figure>
<p>编辑内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">pod &apos;AFNetworking&apos;,&apos;~&gt;2.5.0&apos;</div><div class="line">#使用版本的说明：</div><div class="line">#&gt; 0.1 Any version higher than 0.1.</div><div class="line">#&gt;= 0.1 Version 0.1 and any higher version.</div><div class="line">#&lt; 0.1 Any version lower than 0.1.</div><div class="line">#&lt;= 0.1 Version 0.1 and any lower version.</div><div class="line">#~&gt; 0.1.2 Version 0.1.2 and the versions up to 0.2, not including 0.2.</div></pre></td></tr></table></figure>
<p>保存退出Podfile文件，之后执行 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Pod install</div></pre></td></tr></table></figure>
<p>安装完成后会有提示，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[!] Please close any current Xcode sessions and use `CocoaPodsDemo.xcworkspace` for this project from now on.</div></pre></td></tr></table></figure>
<p>注意提示使用<strong>工程名.xcworkspace</strong>文件</p>
<h3 id="创建私有的-spec-repo"><a href="#创建私有的-spec-repo" class="headerlink" title="创建私有的 spec repo"></a>创建私有的 spec repo</h3><p>pod的库管理可以看~/.cocoapods/repos 文件夹,<br>这个文件夹包含了所有能用到的被管理的库 默认只有 cocoapods 的 spec。</p>
<p>内部的代码不能共享，所以不能够push到 cocoapods 的 sepc 中，只能创建自己的私有的 spec 仓库。</p>
<ol>
<li><p>首先创建 spec 的 git repo。如:<code>git@github.com:zerdzhong/SpecName.git</code></p>
</li>
<li><p>将这个 spec 的 git repo 添加到 cocoapods 中。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod repo add SpecName git@github.com:zerdzhong/SpecName.git</div></pre></td></tr></table></figure>
<p> 可以在下面的路径内查看。这个 repo 里面其实只是存放了每个库提交的podspec文件。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/.cocoapods/repos/SpecName</div><div class="line">pod repo lint . # 验证一下</div></pre></td></tr></table></figure>
<p> 对团队而言，每个人的电脑都需要配置这个私有库的过程（既第二步)执行完这一步原有的~/.cocoapods/repos 文件夹下就增加了一个叫做 SpecName 的文件夹,这样才能将创建的 pod 提交到这个 spec 中。</p>
</li>
</ol>
<p>私有仓库有了，下面创建自己的pod。</p>
<h3 id="创建Pod"><a href="#创建Pod" class="headerlink" title="创建Pod"></a>创建Pod</h3><p>pod 最主要的文件就是 .podsepc  文件，这个文件定义了这个 pod 中的源码的位置，依赖项，等等。可以通过 pod 提供的工具直接创建模板如下：</p>
<ul>
<li><p>pod spec create NAME</p>
<p>  通过终端找到自己要封装成库的工程，在 工程名.workspace 目录层级执行则创建了 工程名.podspec 文件，该文件默认给你自动生成了不少东西<br>  改一下podspec文件 注意所有的注释都要删除</p>
</li>
</ul>
<ul>
<li><p>pod lib create NAME</p>
<p>  需要根据提示选择，选完后会生成一个工程+pod<br>这种情况的话 类文件放到Pod文件夹的Assets文件夹下，图片放到Pod文件夹的Assets文件夹下</p>
<p>  然后通过git add / git commit/ git remote add origin [url]/git push origin master 完成对远程git仓库的提交</p>
</li>
</ul>
<p>写完podspec后,需要简单验证下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod lib lint --allow-warnings(检测你的pod是否OK  如果有error是不可以的)</div></pre></td></tr></table></figure>
<p>提交</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pod repo push SpecName x.podspec --allow-warnings</div></pre></td></tr></table></figure>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>和使用开源的 pod 一样，在 Podfile 中写明对于 Pod 库的依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pod install --no-repo-update 安装的时候不再更新这个库</div><div class="line">pod update</div></pre></td></tr></table></figure>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul>
<li>自己创建的库的互相引用问题，只要引用的版本是一样的就不会有问题。</li>
<li>库的版本管理，每一次的修改对应的版本的修改，修改完后需要打tag 当然直接指向分支的修改也是可以的，但是不便于查找某一个版本的问题</li>
<li>库升级以后的使用这个库的Podfile文件需不需要修改？看怎么写得，如果是指定写死的版本可能需要注意，如果使用了~&gt;则看版本号的情况</li>
<li>如果是测试阶段，那么引用的路径需要指向本地的路径。测试完成后 要记得修改回来</li>
<li>针对图片资源和js资源的处理</li>
<li>库之间的依赖处理</li>
<li>podfile上要写明source 地址</li>
<li>只想用库的一部分</li>
</ul>
<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul>
<li><p><a href="https://www.objc.io/issues/6-build-tools/cocoapods-under-the-hood/" target="_blank" rel="external">cocoapods 介绍</a></p>
</li>
<li><p><a href="https://guides.cocoapods.org/" target="_blank" rel="external">官方guide</a></p>
</li>
<li><p><a href="https://guides.cocoapods.org/syntax/podspec.html" target="_blank" rel="external">创建Pod</a></p>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> CocoaPods </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Swift API Design Guidelines]]></title>
      <url>http://blog.zdzhong.com/2016/07/08/swift-api-design-guidelines/</url>
      <content type="html"><![CDATA[<h3 id="Swift-API-Desgin-Guideline"><a href="#Swift-API-Desgin-Guideline" class="headerlink" title="Swift API Desgin Guideline"></a>Swift API Desgin Guideline</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>每个语言都有它独特的性格，让人看一眼代码就能分辨出来的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">DispatchQueue.main.async &#123;</div><div class="line">	self.listDocumentsViewController?.present(signedOutController, animated: true)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>类似上面这种代码给人的感受是 Swift 希望在整个语言层面都能达到的，但是 Cocoa 的 guideline 是基于 Objective-C 的语言风格来的。</p>
<h4 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h4><p><a href="https://swift.org/documentation/api-design-guidelines/" target="_blank" rel="external">原则</a>：</p>
<ol>
<li><p>Clarity at the point of use</p>
<p> 让 API 在使用的时候很清晰准确是第一位的，函数和属性声明一次，但是要到处使用。设计 API 就是要在使用的时候感觉简洁明了；使用 API 的时候都要有上下文环境。</p>
</li>
<li><p>Clarity is more important than brevity</p>
<p> 不要把代码整洁作为优先级第一的目标，代码的简洁更多是 Swift 3 静态强类型语言的自然结果。</p>
<p> <img src="/images/swift3/clarity1.png" alt=""><br> <img src="/images/swift3/clarity2.png" alt=""></p>
<p> 判断接口里的单词是否冗余，取决于这个单词是否帮助理解了。比如下面的的 <code>addChild(_:at)</code> 接口， child 这个单词表明了是要把view 加到层级接口的子级中，而第二个参数的 point 可以通过参数的 CGPoint 类型看出来肯定是个位置，所有 atPoint 就删去了 point。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mainView.addChild(sideBar, atPoint: origin)</div><div class="line">mainView.addChild(sideBar, at: origin)</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>Write a documentation comment</p>
<p> Swift 3 注释支持 markdown 的变种。可以写出结构更丰富的注释。<a href="https://developer.apple.com/library/mac/documentation/Xcode/Reference/xcode_markup_formatting_ref/" target="_blank" rel="external">文档摸我</a></p>
<p> <img src="/images/swift3/document.png" alt=""></p>
</li>
</ol>
<h4 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h4><ol>
<li><p>保留足够的单词避免歧义</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">extension List &#123;</div><div class="line">	public mutating func remove(at position: Index) -&gt; Element</div><div class="line">&#125;</div><div class="line">employees.remove(at: x)</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>删去不需要的单词</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">override func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int</div><div class="line">override func numberOfSections(in tableView: UITableView) -&gt; Int</div><div class="line">	</div><div class="line">func viewForZoomingInScrollView(scrollView: UIScrollView) -&gt; UIView?</div><div class="line">func viewForZooming(in scrollView: UIScrollView) -&gt; UIView?</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>参数属性关联类型的命名根据角色来，而不是类型</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var string = &quot;Hello&quot;</div><div class="line">protocol ViewController &#123;</div><div class="line">	associatedtype ViewType : View</div><div class="line">&#125;</div><div class="line">class ProductionLine &#123;</div><div class="line">	func restock(from widgetFactory: WidgetFactory)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 上面的代码中命名就不是建议的按照角色来命名的，推荐的命名如下：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var greeting = &quot;Hello&quot;</div><div class="line">protocol ViewController &#123;</div><div class="line">	associatedtype ContentView : View</div><div class="line">&#125;</div><div class="line">class ProductionLine &#123;</div><div class="line">	func restock(from supplier: WidgetFactory)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 如果属性的角色和protocol类型一样，可以加个 Type 关联下。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">protocol Sequence &#123;</div><div class="line">	associatedtype IteratorType : Iterator</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>为弱类型补充额外的信息</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">func addObserver(_ observer: NSObject, forKeyPath path: String)</div><div class="line">grid.addObserver(self, forKeyPath: graphics) // clear</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="调用的流畅"><a href="#调用的流畅" class="headerlink" title="调用的流畅"></a>调用的流畅</h4><ol>
<li><p>调用要尽量符合英语语法</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">x.insert(y, at: z)          “x, insert y at z”</div><div class="line">x.subViews(havingColor: y)  “x&apos;s subviews having color y”</div><div class="line">x.capitalizingNouns()       “x, capitalizing nouns”</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>工厂方法要以 make 开始</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x.makeIterator()</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>初始化方法和工厂方法的短语应该不包括第一个参数</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let foreground = Color(red: 32, green: 64, blue: 128)</div><div class="line">let newPart = factory.makeWidget(gears: 42, spindles: 14)</div></pre></td></tr></table></figure>
<p> 反例：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let foreground = Color(havingRGBValuesRed: 32, green: 64, andBlue: 128)</div><div class="line">let newPart = factory.makeWidget(havingGearCount: 42, andSpindleCount: 14)</div></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>命名函数要根据 side-effects</p>
<ul>
<li>没有副作用的读起来应该是名词短语，比如 <code>x.distance(to: y)</code>, <code>i.successor()</code></li>
<li>有副作用的应该是祈使句动词短语,比如 <code>print(x)</code>,<code>x.sort()</code>,<code>x.append(y)</code></li>
<li><p>Mutating/nonmutating 方法要配对一致</p>
<ul>
<li><p>用动词描述的操作，应该用动词的祈使语气添加 ing 或 ed 后缀表示 mutating 方法<br><img src="/images/swift3/mutating1.png" alt=""></p>
</li>
<li><p>用名次描述的操作，应该添加 form 前缀来表示 mutating 方法<br><img src="/images/swift3/mutating2.png" alt=""></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>返回 boolean 的方法和属性，应该读起来像断言一样。比如：<code>x.isEmpty</code></p>
</li>
<li>描述性质的协议应该起名次的名字。比如 <code>Collection</code></li>
<li>描述能力的协议应该用后缀 able,ible 或者 ing,比如 <code>Equatable</code>,<code>ProgressReporting</code></li>
<li>其他的类型，属性，变量，常量都应该是名词</li>
</ol>
<h3 id="The-Grand-Renaming"><a href="#The-Grand-Renaming" class="headerlink" title="The Grand Renaming"></a>The Grand Renaming</h3><p>将这套 API Guidelines 改进到更大范围的 API 中</p>
<ul>
<li>Swift 标准库</li>
<li>所有 Cocoa 和 Cocoa Touch 框架</li>
<li>Core Graphics 和 GCD 框架</li>
</ul>
<p>一个API，两个名字，在 Objective-C 代码中通过 NS_SWIFT_NAME 声明一个别名给 Swift 使用，在 Swift 代码中通过 @objc 声明 Obejctive-C 函数名。</p>
<p><img src="/images/swift3/rename.png" alt=""></p>
<p>在 Objective-C 中有很多 NSString 的常量，用来表示一种弱类型, 通过 NS_EXTENSIOBLE_STRING_ENUM 自动处理成强类型。 </p>
<p><img src="/images/swift3/wraptype.png" alt=""></p>
<p>#selector,#keyPath 来替换原先的 String</p>
<p> C API，比如 Core Graphics 中的 C API 都不是 Swift 风格的，也是同样的方法通过 NS_SWIFT_NAME  进行了大量的重命名</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let ctx = UIGraphicsGetCurrentContext()</div><div class="line"></div><div class="line">let rectangle = CGRect(x: 0, y: 0, width: 512, height: 512)</div><div class="line">CGContextSetFillColorWithColor(ctx, UIColor.redColor().CGColor)</div><div class="line">CGContextSetStrokeColorWithColor(ctx, UIColor.blackColor().CGColor)</div><div class="line">CGContextSetLineWidth(ctx, 10)</div><div class="line">CGContextAddRect(ctx, rectangle)</div><div class="line">CGContextDrawPath(ctx, .FillStroke)</div><div class="line"></div><div class="line">UIGraphicsEndImageContext()</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">if let ctx = UIGraphicsGetCurrentContext() &#123;</div><div class="line">    let rectangle = CGRect(x: 0, y: 0, width: 512, height: 512)</div><div class="line">    ctx.setFillColor(UIColor.red().cgColor)</div><div class="line">    ctx.setStrokeColor(UIColor.black().cgColor)</div><div class="line">    ctx.setLineWidth(10)</div><div class="line">    ctx.addRect(rectangle)</div><div class="line">    ctx.drawPath(using: .fillStroke)</div><div class="line"></div><div class="line">    UIGraphicsEndImageContext()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>所有的参数说明都默认显示了</li>
<li>很多API删去不必要的单词</li>
<li>Enum的值和属性都统一用小写驼峰命名</li>
<li>Core Graphics 和 GCD 的 C API 都更新命名了</li>
</ol>
]]></content>
      
        <categories>
            
            <category> Swift </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[越狱开发经验小结]]></title>
      <url>http://blog.zdzhong.com/2015/06/02/yue-yu-kai-fa-jing-yan/</url>
      <content type="html"><![CDATA[<h3 id="越狱程序开发"><a href="#越狱程序开发" class="headerlink" title="越狱程序开发"></a>越狱程序开发</h3><p>iOS 和 Mac OS X 公用同样的系统内核（Darwin Unix），提供基本一致的底层系统API，甚至连应用程序的文件结构都基本类似。抛开上层 GUI 来看，iOS 和 Mac OS X 可以看作同一个系统，越狱获取了设备的管理员权限，拥有了读写所有文件的能力，Mac OS X 上的命令行工具都可以安装使用。</p>
<a id="more"></a>
<p>越狱开发相比于上线 App 开发的区别主要就是存在多种不同形式的 “App”（tweak,command-line tool,preference_bundle…）也可以做一些上线 App 不能做的事情，比如以 root 权限运行，调用私有 API，Hook 其他的 APP。</p>
<h4 id="Method-Swizzling-hook"><a href="#Method-Swizzling-hook" class="headerlink" title="Method Swizzling(hook)"></a>Method Swizzling(hook)</h4><p>Method Swizzling 是利用 Runtime 特性把一个方法的实现与另一个方法的实现进行替换。只 hook 自己 App 中的方法，并不会影响 App 上线。</p>
<p>每个类里都有一个 Dispatch Table ，将方法的名字（SEL）跟方法的实现（IMP，指向 C 函数的指针）一一对应。Swizzle 一个方法其实就是在程序运行时在 Dispatch Table 里做点改动，让这个方法的名字（SEL）对应到另个 IMP 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">+ (void)load &#123;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        </div><div class="line">        SEL originalSelector = @selector(paymentWithProduct:);</div><div class="line">        SEL swizzledSelector = @selector(swizzling_paymentWithProduct:);</div><div class="line">        </div><div class="line">        //        Class class = [self class];</div><div class="line">        //        Method originalMethod = class_getInstanceMethod(class, originalSelector);</div><div class="line">        //        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</div><div class="line">        </div><div class="line">        // When swizzling a class method, use the following:</div><div class="line">        Class class = object_getClass((id)self);</div><div class="line">        Method originalMethod = class_getClassMethod(class, originalSelector);</div><div class="line">        Method swizzledMethod = class_getClassMethod(class, swizzledSelector);</div><div class="line">        </div><div class="line">        BOOL didAddMethod = class_addMethod(class,</div><div class="line">                                            originalSelector,</div><div class="line">                                            method_getImplementation(swizzledMethod),</div><div class="line">                                            method_getTypeEncoding(swizzledMethod));</div><div class="line">        </div><div class="line">        if (didAddMethod) &#123;</div><div class="line">            class_replaceMethod(class,</div><div class="line">                                swizzledSelector,</div><div class="line">                                method_getImplementation(originalMethod),</div><div class="line">                                method_getTypeEncoding(originalMethod));</div><div class="line">        &#125; else &#123;</div><div class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark- swizzling </div><div class="line">+ (instancetype)swizzling_paymentWithProduct:(SKProduct *)product</div><div class="line">&#123;</div><div class="line">    id res = [self swizzling_paymentWithProduct:product];</div><div class="line">    </div><div class="line">    NSLog(@&quot;swizzling payment&quot;);</div><div class="line">    </div><div class="line">    return res;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="tweak"><a href="#tweak" class="headerlink" title="tweak"></a>tweak</h4><p>tweak 是越狱 iOS 中的重要组成部分，它的作用相当于插件，主要是通过 hook 住宿主应用的方法来提供一些额外的功能，比如通话录音，短信拦截…由于 Method Swizzling 只能作用于本进程的运行时环境，所以 Tweak 想要 hook 宿主应用就需要通过 dylib 的形式被于宿主应用 load 成为宿主应用的一部分，</p>
<p>MobileSubstrate（Cydia Substrate）是绝大部分 tweak 工作的基础，是一个提供了 Runtime 的 hook 其他方法的 framework。</p>
<p>MobileSubstrate 主要由三个部分组成，MobileHooker,MobileLoader 和 Safe mode。</p>
<ul>
<li><p>MobileHooker</p>
<p>  MobileHooker 的作用是 Hook 函数，主要包含以下两个函数:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">void MSHookMessageEx(Class class, SEL selector, IMP replacement, IMP *result);</div><div class="line"></div><div class="line">void MSHookFunction(void* function, void* relpacement, void** p_original);</div></pre></td></tr></table></figure>
<p>  MSHookMessageEx 作用于 Objective-C函数， MSHookFunction 作用于 C 和 C++ 函数，在进程执行到原始的 function 的时候，转而执行 replacement ,并保存原始 function 的指令和返回地址，可以选择是否执行原始的 function 。</p>
</li>
<li><p>MobileLoader</p>
<p>  MobileLoader 会在 App 运行的时候通过 DYLD_INSERT_LIBRARIES 环境变量运行起来，加载 /Library/MobileSubstrate/DynamicLibraries/     路径下的所有合适的动态库。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// The attribute forces this function to be called on load.</div><div class="line">__attribute__((constructor))</div><div class="line">static void initialize() &#123;</div><div class="line">  NSLog(@&quot;MyExt: Loaded&quot;);</div><div class="line">  MSHookFunction(CFShow, replaced_CFShow, &amp;original_CFShow);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  通过 __attribute__((constructor)) 将函数在 dylib 加载的时候执行， tweak 就是通过这种方式 hook 宿主应用的方法。</p>
</li>
<li><p>Safe mode<br>  由于 tweak 可以 Hook 任意的方法，如果 tweak 的对象是 SpringBoard 时，由于 tweak 的奔溃导致 SpringBoard 奔溃时，MobileLoader 会 catch 住这个 crash ,进入 safe mode,在 safe mode 下不会加载任何 tweak。</p>
</li>
</ul>
<h4 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h4><p>iOS 源于 OSX ，和所有类 UNIX 操作系统一样有 daemon （守护进程），越狱之后放开了苹果的限制之后，可以实现自己的 daemon。iOS 上的 daemon 由一个可执行文件和一个 plist 文件组成。 iOS 的根进程时 launchd ，它会在开机的时候检测 /System/Library/LaunchDaemons 和 /Library/LaunchDaemons 路径下的所有符合规定的 plist 文件。这个 plist 文件记录了 daemon 的基本信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;Program&quot; =&gt; &quot;/usr/libexec/adDaemon&quot;</div><div class="line">  &quot;RunAtLoad&quot; =&gt; 1</div><div class="line">  &quot;KeepAlive&quot; =&gt; 1</div><div class="line">  &quot;Label&quot; =&gt; &quot;cn.domob.adDaemon&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="THEOS"><a href="#THEOS" class="headerlink" title="THEOS"></a>THEOS</h4><p>越狱的开发工具和 普通 APP 的开发不太一样，没法完全依赖 Xcode 。THEOS 就是一个功能简化版的越狱开发 Xcode。</p>
<p>THEOS 用内建的 Logos 语法对 MobileSubstrate 进行了封装。也提供了快速创建 tweak 和 daemon 的模板。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#import &lt;SpringBoard/SpringBoard.h&gt;</div><div class="line"></div><div class="line">%hook SpringBoard</div><div class="line"></div><div class="line">-(void)applicationDidFinishLaunching:(id)application &#123;</div><div class="line">	%orig;</div><div class="line">	  </div><div class="line">	UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;Welcome&quot;</div><div class="line">		          									message:@&quot;Hello Tweak&quot;</div><div class="line">				          						   delegate:nil</div><div class="line">						          		  cancelButtonTitle:@&quot;确定&quot;</div><div class="line">								          otherButtonTitles:nil];</div><div class="line">	[alert show];</div><div class="line">	[alert release];</div><div class="line">&#125;</div><div class="line"></div><div class="line">%end</div></pre></td></tr></table></figure>
<p>以上代码是 hook SpringBoard 的 applicationDidFinishLaunching 方法后弹出一个 alertView。</p>
<ul>
<li><p>目前情况</p>
<p>  tweak 是以 dylib 的形式存在，受限于 tweak 的对象，如果 tweak 的对象是普通的 app ，那么权限很低，依赖性太强。如果 tweak 的是 springboard 就相对灵活，但是较为危险，导致 safe mode。</p>
<p>  daemon 以后台守护进程存在，没找到好的办法在 daemon 的进程中直接 hook 目标 app ，可以通过 cycript 间接的达到目的（代码不够灵活）。</p>
</li>
</ul>
<h3 id="工具集"><a href="#工具集" class="headerlink" title="工具集"></a>工具集</h3><h4 id="静态分析工具"><a href="#静态分析工具" class="headerlink" title="静态分析工具"></a>静态分析工具</h4><ul>
<li><p>dumpdecrypted </p>
<p>  在 AppStore 上的 app 经过了苹果的一层加密，在可执行文件外包了一层，使用 dumdecrypted 工具进行砸壳之后，才能获取到原始的可执行文件。</p>
</li>
<li><p>class-dump</p>
<p>  class-dump 利用 runtime 特性将 Mach-O 格式的二进制文件的头文件信息 dump 出来。</p>
</li>
<li><p>idaq/Hopper</p>
<p>  反汇编器，可以用来查看二进制文件的汇编代码。</p>
</li>
</ul>
<h4 id="动态分析工具"><a href="#动态分析工具" class="headerlink" title="动态分析工具"></a>动态分析工具</h4><ul>
<li><p>cycript</p>
<p>  这个工具可以轻松的注入目标 app ，获取对象在内存中的地址，通过对象调用方法，获取数据。</p>
</li>
<li><p>lldb + debugserver</p>
<p>  lldb 是运行在 OSX 中的调试器，和 debugserver 配合可以对 iOS 设备上的 app 进行 debug。</p>
</li>
</ul>
<h3 id="逆向目标-app-的主要思路"><a href="#逆向目标-app-的主要思路" class="headerlink" title="逆向目标 app 的主要思路"></a>逆向目标 app 的主要思路</h3><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><ul>
<li>准备工作<ul>
<li>砸壳</li>
<li>class-dump</li>
</ul>
</li>
<li>定位功能<ul>
<li>cycript     </li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>从界面上定位关心的功能，根据 view 层级定位到相应的类名。</li>
<li>从相应类的头文件中寻找突破点，使用 cycript 快速验证。</li>
<li>必要时使用 Hopper/idaq 看实现方法。</li>
</ol>
<p>相关链接：</p>
<p><a href="http://nshipster.com/method-swizzling/" target="_blank" rel="external">method-swizzling</a></p>
<p><a href="http://www.cycript.org/manual/" target="_blank" rel="external">cycript-manual</a></p>
<p><a href="http://iphonedevwiki.net/index.php/Main_Page" target="_blank" rel="external">iphonedevwiki</a></p>
]]></content>
      
        <categories>
            
            <category> 越狱开发 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 多线程技术总结-2]]></title>
      <url>http://blog.zdzhong.com/2015/02/05/ios-concurrency-programming-2/</url>
      <content type="html"><![CDATA[<p>上一篇总结了iOS中提供的一些实现并发的技术，这一篇主要总结一下GCD。<a id="more"></a></p>
<p>GCD(Grand Central Dispatch) 是为了提高 OS X 和 iOS 系统在多核处理器上运行并行代码的能力而开发的一系列相关技术，是苹果最推荐使用的实现并行的技术，NSOperationQueue 就是在 GCD 的基础上实现的，基本原理相似只不过是将 block 添加到 dispatch queue 中和 operation 添加到 operation queue 中的区别，dispatch queue 是严格的先进先出结构，无法直接使用优先级或调整 block 的执行顺序，如果有此需求最好使用 Operation Queue 而不是重新发明轮子。</p>
<p>GCD 提供一套纯 C 的 API，需要和 block 配合使用。block 是 GCD 的执行单元，dispatch queue 是组织 block 的，dispatch queue 就是队列，不是线程。将 block 添加到队列中并不会让 block 运行，只是把 block 加到线程末尾。Dispatch queue 来调度 block 的执行。</p>
<h2 id="Dispatch-Queue"><a href="#Dispatch-Queue" class="headerlink" title="Dispatch Queue"></a>Dispatch Queue</h2><p>Dispatch queue 是执行任务的有力工具，dispatch queue 能够异步或者同步的执行任意多个block。在 GCD 中有三中 dispatch queue :</p>
<p>1.串行队列（Serial dispatch queue）<br>     串行分发队列也称为私有分发队列（Private dispatch queue）,队列中的任务按照加入队列的顺序依次执行，且同一时间只执行一个任务，常被用于实现同步锁，由于串行队列中正在执行的任务实在单独的线程中，所以串行对列相对于其他线程或队列是并发的。创建一个串行分发队列：</p>
<p>dispatch_queue_t serialQueue = dispatch_queue_create(“com.example.MyQueue”, NULL);</p>
<p>2.并发队列（Concurrent dispatch queue）<br>     并行分发队列也称为全局分发队列（Global dispatch queue）,队列中的任务也按照加入的顺序依次执行，但是同时可以执行多个任务。正在执行的任务在不同的线程上执行，这些线程由队列管理。创建一个并发队列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//1.由系统提供的四种全局分发队列中获取</div><div class="line">dispatch_queue_t aQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</div><div class="line"></div><div class="line"></div><div class="line">//2.手动创建</div><div class="line">dispatch_queue_t bQueue = dispatch_queue_create(&quot;com.example.MyQueue&quot;,DISPATCH_QUEUE_CONCURRENT );</div></pre></td></tr></table></figure>
<p>3.主队列（Main dispatch queue）<br>主分发队列是一个全局唯一的特殊的串行分发队列。队列中的任务会被在应用的主线程中执行。主分发队列可以用于执行 UI 相关的操作。取得主分发队列的方法：<br>dispatch_queue_t mainQueue = dispatch_get_main_queue();</p>
<p>使用 dispatch queue 来替代线程实现程序并发的好处在于，不需要写管理线程的代码，关注在真正需要并发的任务实现上，系统处理了所有创建线程，管理线程的工作（比应用中手动管理更有效率，通常比手动开线程更快的执行）。</p>
<p>dispatch queue 的一些关键特性如下：<br>dispatch queue 相对其他队列来说都是并发的，串行的任务只在所在的串行队列中被限制。<br>系统决定同时执行的任务数。假如有100个任务分别加入100个队列中，也不一定会同时执行所有的任务。<br>系统会将队列的优先级作为选择哪个任务下一个执行的考虑因素。</p>
<h2 id="GCD-任务执行方式"><a href="#GCD-任务执行方式" class="headerlink" title="GCD 任务执行方式"></a>GCD 任务执行方式</h2><p>GCD 中有两种任务执行方式：<br>     异步执行, dispatch_async，意味将任务放入队列之后，主线程不会等待 block 的返回结果，而是立即继续执行下去。<br>     阻塞执行, dispatch_sync，意味将任务放入队列之后，主线程被阻塞，需要等待 block 的执行结果返回，才能继续执行下去。</p>
]]></content>
      
        <categories>
            
            <category> iOS Concurrency </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[iOS 多线程技术总结-1]]></title>
      <url>http://blog.zdzhong.com/2015/01/08/ios-concurrency-programming-1/</url>
      <content type="html"><![CDATA[<p>多线程其实是为了实现并发执行，而且线程是并发执行多个代码路径的多种技术之中比较轻量级的一种（对应较重的实现是多进程）。<a id="more"></a></p>
<p>iOS &amp; OS X 实现多线程的方法的以下几种方式：</p>
<ul>
<li><p>POSIX 线程模型，iOS &amp; OS X 提供了一套底层的 C 语言的 POSIX 线程 API 来创建管理线程，除非考虑到跨平台，一般极少直接使用 POSIX 线程 API。</p>
</li>
<li><p>NSObject 提供的以 performSelector 为前缀的一系列方法。这一系列方法简单易用，但只提供几个选择：指定执行的方法（但传入方法的参数数量有限制）；指定是在当前线程，还是在主线程，还是在后台线程执行；指定是否需要阻塞当前线程等待结果。</p>
</li>
<li><p>NSTread 是 iOS 和 OS X 都提供的线程对象，是线程的一个轻量级实现。NSThread 适合执行一些轻量级的简单任务。因为使用 NSThead 仍然需要手动管理线程生命周期，进行线程间同步。线程状态，依赖性，线程间同步等线程相关的主题 NSThread 都没有涉及。比如，涉及到线程间同步仍然需要配合使用 NSLock，NSCondition 或者 @synchronized。所以，遇到复杂任务时，轻量级的 NSThread 并不合适。</p>
</li>
<li><p>NSOperation 做的事情比 NSThread 更多。继承 NSOperation 的子类获得一些线程相关的特性，可以安全地管理线程生命周期。比如，以线程安全的方式建立状态，取消线程。配合 NSOperationQueue，可以控制线程间的优先级和依赖性。</p>
</li>
<li><p>GCD(Grand Central Dispatch) 提供了线程的高级抽象，GCD 将线程管理的操作集成进系统中，不需要程序员手动管理。将需要并发的代码通过 block 加入到合适的 dispatch queue 中，由 GCD 处理线程管理、调度等工作。</p>
</li>
</ul>
<p>苹果官方推荐使用 GCD 或者 NSOperation 结合 NSOperationQueue 的方式实现并发。</p>
<h2 id="Operation-Queues"><a href="#Operation-Queues" class="headerlink" title="Operation Queues"></a>Operation Queues</h2><p>Operation Queues 是以 Operation 为中心。Operation 是 NSOperation 类的实例，是经过封装的 工作单元。NSOperation 是抽象基类，必须被子类继承才能使用。Foundation framework 中有两种已经实现好的子类为：NSInvocationOperation,NSBlockOperation。</p>
<p>Operation 支持以下特性：<br>Operation 对象之间支持基于图的依赖关系，这些依赖关系能保证 Operation 对象在所有依赖的 Operation 执行之后再执行。<br>支持可选的完成 block 在 Operation 的 main task 完成之后执行。<br>支持 KVO 监听 Operation 状态的改变。<br>支持优先级操作，影响 Operation 的相对执行顺序。<br>支持取消语法，允许停止一个正在执行的 Operation。</p>
<p>Operations 被设计用来帮助提高应用的并发级别，同时也是一个很好的将应用的行为包含在各个分离的块中方法。可以将一个或多个 Operation 对象提交到队列中，让一个或多个独立的线程异步执行相应的工作，而不是在应用程序的主线程上执行一堆的代码。</p>
<p>虽然通常执行 Operations 是通过将其添加到 Operation Queue 中，但是手动调用 start 方法也可以让 Operation 执行，这样做是否能够并发取决于在子线程中调用 start 方法，可以通过 isConcurrent 方法来判断。通常情况下对于调用 start 方法的线程来说 Operation 是同步的。</p>
<p>想实现对于调用线程来说并发的 Operation 需要一些额外的代码来异步的开始 Operation。例如，开辟额外的线程，调用异步的方法等。绝大多数情况是不需要这么做的，只要我们将同步的 Operation 加入到 Operation Queue 中，队列会自动为 Operation 创建一个线程，因此同步的 Operation 加入到队列中之后表现的和异步一样。</p>
<h3 id="NSInvocationOperation"><a href="#NSInvocationOperation" class="headerlink" title="NSInvocationOperation"></a>NSInvocationOperation</h3><p>NSInvocationOperation 是 NSOperation 的子类，当运行的时候，会调用指定对象的指定selector，使用这个类可以省去大量实现自定义 NSOperation 子类的代码，特别是对已有项目修改时已经有了可以执行具体任务的方法的情况。也可以实现根据情况来调用某个方法，比如可以使用 NSInvocationOperation 根据用户输入来动态执行一个 selector。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (NSOperation * )taskWithData:(id)data &#123;</div><div class="line">	NSInvocationOperation* theOp = [[NSInvocationOperation alloc]initWithTarget:self selector:@selector(myTaskMethod:) object:data];</div><div class="line">	</div><div class="line">return theOp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// This is the method that does the actual work of the task.</div><div class="line">- (void)myTaskMethod:(id)data &#123;</div><div class="line">// Perform the task.</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="NSBlockOperation"><a href="#NSBlockOperation" class="headerlink" title="NSBlockOperation"></a>NSBlockOperation</h3><p>NSBlockOperation 是 NSOperation 的子类，是对一个或多个 block 对象的封装，这个类为已经使用 Operation Queue 但不想使用 dispatch queue 的 block 提供了面向对象的封装。也可以使用 block operation 实现 dispatch queue 不支持的依赖，KVO 等特性。</p>
<p>创建 block operation 一般使用最少一个 block 来初始化，初始化后可以添加其他的 block。当 NSBlockOperation 对象执行的时候，对象会把所有的 block 添加到默认优先级、并发的 dispatch queue 中。NSBlockOperation 对象会在所有 block 执行结束后返回，当最后一个 block 结束之后，block operation 对象会将自己标记位 finished。因此可以通过 block operation 来追踪一组 block 的执行。就像使用一个线程合并来自多个线程的返回值一样，区别在于 block operation 在一个子线程中执行，应用的其他线程不会因为 block operation 阻塞。<br>//sample<br>NSBlockOperation* theOp = [NSBlockOperation blockOperationWithBlock: ^{<br>     NSLog(@”Beginning operation.\n”);<br>     // Do some work.<br>}];</p>
<p>在创建 block operation 对象之后可以通过 addExecutionBlock: 方法来添加更多的 block。如果需要顺序的执行 blocks ，需要直接使用 dispatch queue。</p>
<h3 id="自定义-Operation"><a href="#自定义-Operation" class="headerlink" title="自定义 Operation"></a>自定义 Operation</h3><p>如果 NSBlockOperation 和 NSInvocationOperation 不满足需求，就需要直接实现 NSOperation 的子类添加所需要的行为。NSOperation 提供了一些基础的功能，处理了大部分依赖和 KVO 的工作。</p>
<p>定义一个同步的 operation 子类比实现一个异步的 operation 简单很多，对于同步的 operation 来说需要做的就是实现 main task 以及在适当的处理取消事件，其他工作父类已经处理了。对于异步的 operation 需要重写很多父类的方法。</p>
<h4 id="实现-main-task"><a href="#实现-main-task" class="headerlink" title="实现 main task"></a>实现 main task</h4><p>官方建议自定义的 Operation 类最少需要实现两个方法：init 和 main 。<br>init 方法用来初始化 operation 对象，并将需要的参数传给 Operation<br>main 方法用来执行自定义的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//.h</div><div class="line">@interface MyNonConcurrentOperation : NSOperation</div><div class="line">@property id (strong) myData;</div><div class="line">-(id)initWithData:(id)data;</div><div class="line">@end</div><div class="line"></div><div class="line">//.m</div><div class="line">@implementation MyNonConcurrentOperation</div><div class="line">- (id)initWithData:(id)data &#123;</div><div class="line">     if (self = [super init])</div><div class="line">          myData = data;</div><div class="line">     return self;</div><div class="line">&#125;</div><div class="line">-(void)main &#123;</div><div class="line">     @try &#123;</div><div class="line">     // Do some work on myData and report the results.</div><div class="line">     &#125;@catch(...) &#123;</div><div class="line">     // Do not rethrow exceptions.</div><div class="line">     &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>但是实际上 init 函数也不一定要实现，可以通过属性设置 operation 所需的数据，这样调用父类的 init 的函数即可。</p>
<p>总结一下 Operation 的关键特性：</p>
<ul>
<li><p>所有必需的数据都要在开始之前传递给 operation（通过init 方法/设置属性等），这样能避免运行过程中和其他对象交互，避免了加锁。</p>
</li>
<li><p>操作完成后结果保存在自身 ivar中，让使用者在 completionBlock中根据 operation 的对象取出结果，这样也是避免加锁。</p>
</li>
<li><p>main 方法中定期检查 isCancelled 属性，以便在接收到取消事件的时候能够退出。这点很重要。可以在循环中检查，在任何相对容易停止 operation 的地方都可以检查。</p>
</li>
</ul>
<p>不管是自定义的 Operation 还是系统提供的两个 Operation 初始化之后，加入 operation queue 之前都可以对 operation 对象进行相关设置：<br>依赖，通过 addDependency: 函数为 operation 添加依赖的 operation，可以依次添加依赖成为联系执行的队列，也可以添加成复杂的图依赖，但是注意不要形成环。<br>优先级，setQueuePriority: 这只会所在的 queue 起作用，且优先满足依赖的情况下确定相对顺序。setThreadPriority: 必须在添加到队列之前调用，且只对 operation 中 main 方法中的代码起作用。<br>完成的 block，setCompletionBlock: 设置完成的 block 。可以在此block 中根据 operation 属性获取结果。</p>
<h4 id="添加到-operation-queue"><a href="#添加到-operation-queue" class="headerlink" title="添加到 operation queue"></a>添加到 operation queue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSOperationQueue* aQueue = [[NSOperationQueue alloc] init];</div><div class="line">[aQueue addOperation:anOp]; // Add a single operation</div><div class="line">[aQueue addOperations:anArrayOfOps waitUntilFinished:NO]; // Add multiple operations</div><div class="line">[aQueue addOperationWithBlock:^&#123;</div><div class="line">     /* Do something. */</div><div class="line">&#125;];</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> iOS Concurrency </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[为已有的viewController绑定xib]]></title>
      <url>http://blog.zdzhong.com/2014/12/26/binding-exist-viewcontroller-with-xib/</url>
      <content type="html"><![CDATA[<p>最近想把以前手写布局的项目改为使用autolayout，需要为已有的viewcontroller绑定xib，最方便的做法就是新建一个viewcontroller勾选上xib。再相关代码移过去。不过我尝试使用直接新建一个empty xib文件，绑定上已有的viewcontroller类的方法。</p>
<a id="more"></a>
<p>首先新建一个空的xib文件，将xib文件名和viewcontroller类名保持一致。</p>
<p><img src="/images/bindingxib/empty-xib.png" alt=""></p>
<p>然后尝试下拖入一个viewcontroller，并且将 file owner 的 custome class改为viewcontroller类名。</p>
<p><img src="/images/bindingxib/add-viewcontroller.png" alt=""></p>
<p>勇敢的运行，结果华丽丽的出错了。=_=!<br>错误信息是：<br>&gt;<br>Terminating app due to uncaught exception ‘NSInternalInconsistencyException’, reason: ‘-[UIViewController _loadViewFromNibNamed:bundle:] loaded the “DealDetailInfoController” nib but the view outlet was not set.’</p>
<p>是因为没有绑定 view ,连线，再试~<br>又错了。。。<br>&gt;<br>A view can only be associated with at most one view controller at a time!</p>
<p>soga。是因为view已经绑定拖进来的viewcontroller。于是乎，将这个viewcontroller控件删掉，重新拖进来一个UIView控件。</p>
<p><img src="/images/bindingxib/addview.png" alt="emptyxib"></p>
<p>再连接 file owner 的 view 。</p>
<p><img src="/images/bindingxib/setview.png" alt="emptyxib"></p>
<p>运行，Bingo! OK 了。</p>
]]></content>
      
        
    </entry>
    
  
  
</search>
